<html><head>
<style>
#info {
	position: absolute;
	top: 2%;
	width: 100%;
	padding: 10px;
	text-align: center;
	color: #ff0000
}

body {
	overflow: hidden;
}

#topView {
	position: absolute;
	border-radius: 100px;
	top: 86.5%;
	left : 5%;
}
#thirdPV {
	position: absolute;
	border-radius: 100px;
	top: 86.5%;
	left : 15%;
}

#firstPV{
	position: absolute;
	border-radius: 100px;
	top: 86.5%;
	left : 25%;
}

</style>
</head>

<body> 
<div id="info">car
</div>

<script src="https://threejs.org/build/three.min.js"></script>
<script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script src="https://jyunming-chen.github.io/tutsplus/js/KeyboardState.js"></script>

<button id="topView"><img src ="https://i.imgur.com/96tj0yh.png?2" style="width:80px;height:80px;"></button>
<button id="thirdPV"><img src="https://i.imgur.com/OvvIh4R.png?2" style="width:80px;height:80px;"></button>
<button id="firstPV"><img src="https://i.imgur.com/AX5vRqY.png" style="width:80px;height:80px;"></button>

<script>
( function( ) {
	Math.clamp = function(val,min,max) {
		return Math.min(Math.max(val,min),max);
	} 
} )();

$("#topView").click(function() {
	topViewTurn = !topViewTurn;
});
$("#thirdPV").click(function() {
	thirdPV = !thirdPV;
	if(thirdPV)
		firstPV = false;
});
$("#firstPV").click(function() {
	firstPV = !firstPV;
	if(firstPV)
		thirdPV = false;
});

var scene, renderer, camera;
var keyboard = new KeyboardState();
var clock = new THREE.Clock();

var car, leftfrontWheel, rightfrontWheel, leftRearWheel, rightRearWheel;
var theta = 0.001;  // car orientation

//button 
var sceneHUD;
var topViewTurn = false, topControls;
var thirdPV = false;
var firstPV = false;

///chase camera
var state = [0,0], tail, clock;
var tailVec = new THREE.Vector3 (-1,0,0);

init();
animate();

function init() {
	scene = new THREE.Scene();
	renderer = new THREE.WebGLRenderer();
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setClearColor(0x888888);
	document.body.appendChild(renderer.domElement);

	camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
	camera.position.set(-200, 100, 0);
	let controls = new THREE.OrbitControls(camera, renderer.domElement);
	
	//topCamera
	topCamera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
	topCamera.position.set(-10, 390, 0);
	topControls = new THREE.OrbitControls(topCamera, renderer.domElement);
	cameraHUD = new THREE.OrthographicCamera(-10, 10, 10, -10, -10, 1000);
	cameraHUD.position.z = 500;
	sceneHUD = new THREE.Scene();
	renderer.autoClear = false;

	var light = new THREE.HemisphereLight(0xffffff, 0x000000, 1);
	light.position.set(0, 100, 0);
	scene.add(light);

	var grid = new THREE.GridHelper (400,40,'red','white');
	scene.add (grid);
	
	////////////////////////////////////////////////////////////
	car = buildCar();  
	car.position.y = 13;

	scene.add(car);

	window.addEventListener('resize', onWindowResize, false);

	////////////////////////////
	RCmesh = new THREE.Mesh (new THREE.SphereGeometry(5,6,6), new THREE.MeshBasicMaterial());
	scene.add(RCmesh);
	
	drawParkingSpace();
	//buildSteeringWheel();////////////HUD
	
}

function buildSteeringWheel() {
	let loader = new THREE.TextureLoader();
	loader.setCrossOrigin('');
	let circle = new THREE.Mesh(new THREE.CircleGeometry(5, 32), 
	new THREE.MeshBasicMaterial({map: loader.load ('https://i.imgur.com/AaejjAQ.png'), 
							   transparent: true, side:THREE.DoubleSide}));
}

function buildCar() {
	let loader = new THREE.TextureLoader();
	loader.setCrossOrigin('');

	var materialArray = [];
	materialArray.push(new THREE.MeshLambertMaterial({
		map: loader.load ('http://i.imgur.com/3hnQcus.png'), 
		transparent: true, opacity: 0.7
	}));
	materialArray.push(new THREE.MeshLambertMaterial({
		map: loader.load ('http://i.imgur.com/oPWLR0Y.png'), 
		transparent: true, opacity: 0.7
	}));
	materialArray.push(new THREE.MeshLambertMaterial({
		map: loader.load ('http://i.imgur.com/qTj48LD.png'), 
		transparent: true, opacity: 0.7
	}));
	materialArray.push(new THREE.MeshLambertMaterial({
		map: loader.load ('http://i.imgur.com/qTj48LD.png'), 
		transparent: true, opacity: 0.7
	}));
	materialArray.push(new THREE.MeshLambertMaterial({
		map: loader.load ('http://i.imgur.com/oWaSyZJ.png'), 
		transparent: true, opacity: 0.7
	}));
	materialArray.push(new THREE.MeshLambertMaterial({
		map: loader.load ('http://i.imgur.com/oWaSyZJ.png'), 
		transparent: true, opacity: 0.7
	}));

	var carBodyGeometry = new THREE.BoxGeometry(38, 20, 20);
	var carBodyMaterial = new THREE.MeshBasicMaterial({
		color: 0x0000ff
	});
	let body = new THREE.Mesh(carBodyGeometry, materialArray);

	let wheelGeometry = new THREE.CylinderGeometry(5, 5, 2, 32, 1, true);
	let wheelMaterial = new THREE.MeshBasicMaterial({
		color: 0x000000
	});
	let circle = new THREE.Mesh(new THREE.CircleGeometry(5, 32), 
	new THREE.MeshBasicMaterial({map: loader.load ('http://i.imgur.com/8enBd95.png'), 
							   transparent: true, 
							   side:THREE.DoubleSide}));
	circle.rotation.x = Math.PI/2;
	circle.position.y = 1;
	circle2 = circle.clone();
	circle2.position.y = -1;

	// assembly
	car = new THREE.Group();
	leftfrontWheel = new THREE.Group();
	rightfrontWheel = new THREE.Group();
	leftRearWheel = new THREE.Group();
	rightRearWheel = new THREE.Group();

	car.add(body, leftfrontWheel, rightfrontWheel, leftRearWheel, rightRearWheel);

	// wheels
	let mesh1 = new THREE.Mesh(wheelGeometry, wheelMaterial);
	leftfrontWheel.position.set(13, -8, -8);
	mesh1.add(circle);
	mesh1.add(circle2);
	leftfrontWheel.add(mesh1);
	//important!!
	mesh1.rotation.x = Math.PI/2;

	let mesh2 = mesh1.clone();;
	rightfrontWheel.position.set(13, -8, 8);
	rightfrontWheel.add(mesh2);
	
	let mesh3 = mesh1.clone();;
	leftRearWheel.position.set(-13, -8, -8);
	leftRearWheel.add(mesh3);

	let mesh4 = mesh1.clone();;
	rightRearWheel.position.set(-13, -8, 8);
	rightRearWheel.add(mesh4);
	
	tail = new THREE.Object3D();

	let tailMesh = new THREE.Mesh(new THREE.BoxGeometry(22, 1, 1),
	new THREE.MeshBasicMaterial({
		color: 0xffff34,
		transparent: true,
		opacity: 0.3
	}));
	tail.add(tailMesh);
	tailMesh.rotation.y = -Math.PI/2;
	tailMesh.position.z = -11;
	tail.position.x = -26;
	tail.children[0].material.visible = !tail.children[0].material.visible ;
	car.add (tail);
	
	return car;
}

function drawParkingSpace(){
    const material = new THREE.LineBasicMaterial( { color: 0xffff00 } );
    const points = [];
    points.push( new THREE.Vector3( 25, 0, 13 ) );
    points.push( new THREE.Vector3( 25, 0, 40 ) );
    points.push( new THREE.Vector3( -25, 0, 40 ) );
    points.push( new THREE.Vector3( -25, 0, 13 ) );
    points.push( new THREE.Vector3( 25, 0, 13 ) );

    const geometry = new THREE.BufferGeometry().setFromPoints( points );
    const parkingSpace1 = new THREE.Line( geometry, material );
    scene.add( parkingSpace1 );

    var parkingSpace2 = parkingSpace1.clone();
    parkingSpace2.position.x = 55;
    scene.add(parkingSpace2);

}

function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
}

function moveTail (dt) {
	let vel = new THREE.Vector3(animate.speed, 0, 0);
	vel.applyAxisAngle(new THREE.Vector3(0, 1, 0), theta);
	computeTheta (vel, tailVec);
	PDupdate (dt);

	// compute new tailVec based on state[0]
	tailVec = vel.clone().normalize().applyAxisAngle (new THREE.Vector3(0,1,0), state[0]);
	return state[0];
}

function computeTheta(vel, tailVec) {
	let phi = tailVec.angleTo (vel);
	let cross = new THREE.Vector3();

	if (cross.crossVectors(vel, tailVec).dot(new THREE.Vector3(0,1,0)) > 0) 
		state[0] = phi; 
	else
		state[0] = 2*Math.PI - phi;
}

function PDupdate (dt) {

	// compute feedback force
	const KP = 50;
	const KD = 20;
	const thetaRef = Math.PI;

	let f = -KP*(state[0] - thetaRef) - KD*state[1];

	// Euler for state
	state[1] += f*dt;
	state[0] += state[1]*dt
}


function animate() {

	keyboard.update();

	// 'static' variables  
	this.speed = (this.speed === undefined) ? 0 : this.speed;
	this.fSlowDown = (this.fSlowDown === undefined) ? 0 : this.fSlowDown;
	this.bSlowDown = (this.bSlowDown === undefined) ? 0 : this.bSlowDown;
	this.LFW = (this.LFW === undefined) ? 0 : this.LFW;
	this.RFW = (this.RFW === undefined) ? 0 : this.RFW;
	this.LRW = (this.LRW === undefined) ? 0 : this.LRW;
	this.RRW = (this.RRW === undefined) ? 0 : this.RRW;  

	/////////////////////////////////////////////////////////////////
	//move car
	if (keyboard.pressed('down')) 
		this.speed -= 1;
	if (keyboard.pressed('up'))
		this.speed += 1;
	this.speed = Math.clamp (this.speed, -50, 50);

	if (keyboard.pressed('right'))
		theta -= 0.02;
	if (keyboard.pressed('left'))
		theta += 0.02;  
	theta = Math.clamp (theta, -0.89, 0.89);
	
	leftfrontWheel.rotation.y = Math.atan(26/(26/Math.tan(theta)-8));
	rightfrontWheel.rotation.y = Math.atan(26/(26/Math.tan(theta)+8));
	
	//  let msg = `theta: ${theta}; speed: ${this.speed}`;
	//  console.log (msg);

	//////////////////////////////////////////////////////////////
  
	RC = car.localToWorld (new THREE.Vector3(-13,0,-26/Math.tan(theta)));
	RCmesh.position.copy (RC);

	var omega = this.speed * Math.tan(theta)/26;//W
	var deltaT = clock.getDelta();

	// C is the center of car body
	let C = car.position;
	
	var vv = C.clone().sub(RC).applyAxisAngle (new THREE.Vector3(0,1,0), omega*deltaT).add(RC);//C'=RC+Rot(Y,W*deltaT)*(C-RC)
	car.position.copy(vv);
	car.rotation.y += omega*deltaT;//Rot(Y,W*deltaT)

	//camera.position.set(-200, 100, 0); // fixed camera, no orbitControl!
    
	//////////////////////////////////////////////////////////////
	// slowing down    after keyboard up
	//
	if (keyboard.up("up")) 
		this.fSlowDown = 1; 
	else if (keyboard.up("down"))	
		this.bSlowDown = 1;

	if (keyboard.down("up") ||  keyboard.down("down"))
		this.fSlowDown = this.bSlowDown = 0;

	if (this.fSlowDown == 1) {

		if(this.speed >= 0) {  // moving forward --> slow down gradually
			this.speed -= 1;
		} else if (this.speed <= 0) {  // moving backward --> stop immediately
			this.speed = 0;
			this.fSlowDown = 0;
		}
    
	} else if (this.bSlowDown == 1) {

		if(this.speed <= 0) {
			this.speed += 1;
		} else if (this.speed >= 0) {
			this.speed = 0;
			this.bSlowDown = 0;
		}

	}
	
	////////////tail
	var dt = clock.getDelta();
	let tailAngle = moveTail (dt);
	tail.rotation.y = tailAngle - Math.PI;
	
	
	/////////////////////////////////////////////
	// purely cosmetic ...    wheel turn
	this.LFW += this.speed*deltaT/5;
	this.RFW += this.speed*deltaT/5;
	this.LRW += this.speed*deltaT/5;
	this.RRW += this.speed*deltaT/5;

	leftfrontWheel.rotation.z = this.LFW;
	rightfrontWheel.rotation.z = this.RFW;
	leftRearWheel.rotation.z = this.LRW;
	rightRearWheel.rotation.z = this.RRW;

	requestAnimationFrame(animate);
	render();
}

function render() {
	renderer.clear();
	const WW = window.innerWidth;
	const HH = window.innerHeight;
	
	if (thirdPV) {
		let carEnd = car.localToWorld (new THREE.Vector3(-10,0,0));
		camera.lookAt (carEnd);
		camera.position.copy (tail.localToWorld (new THREE.Vector3 (0,20,-40)));
	}
	else if(firstPV){////////dark
		let carEnd = car.localToWorld (new THREE.Vector3(5, 10, 0));
		camera.lookAt (carEnd);
		let tmp = car.localToWorld(new THREE.Vector3(-10, 10, 0));
		camera.position.set(tmp);
		console.log(carEnd, tmp);
	}
	else{
		let carEnd = car.localToWorld (new THREE.Vector3(0,0,0));
		camera.lookAt (carEnd);
		camera.position.set(-200, 100, 0);
	}
	
	//topView
	renderer.setScissorTest( true );
	renderer.setViewport(0, 0, WW, HH);
	renderer.setScissor(0, 0, WW, HH);
	renderer.clear();
	renderer.render(scene, camera);

	if (topViewTurn) {
		renderer.render(sceneHUD, cameraHUD);
		renderer.setViewport(WW/1.43, HH/1.41, WW/3.5, HH/3.5);
		renderer.setScissor(WW/1.43, HH/1.41, WW/3.5, HH/3.5);
		renderer.clear();
		renderer.render(scene, topCamera);
	}
	renderer.setScissorTest( false );
}
</script>

</body>

</html>